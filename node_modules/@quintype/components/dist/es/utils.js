import _objectSpread from "@babel/runtime/helpers/objectSpread";
var _arguments = arguments;
// FIXME: TEST THIS
import get from "lodash/get";
export function removeDuplicateStories(existingStories, newStories) {
  var keyFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (story) {
    return story.id;
  };
  var existingStoryIds = existingStories.map(keyFn);
  return newStories.filter(function (story) {
    return !existingStoryIds.includes(keyFn(story));
  });
}
export function getAssociatedTemplate(_ref) {
  var associatedMetadata = _ref["associated-metadata"];
  return associatedMetadata ? associatedMetadata.layout : 'default';
} // FIXME: TEST THIS

export function replaceAllStoriesInCollection(collection, story) {
  var items = (collection.items || []).map(function (item) {
    if (item.type === "story") {
      return {
        id: story.id,
        type: "story",
        story: story
      };
    } else if (item.type === "collection") {
      return replaceAllStoriesInCollection(item, story);
    }

    return item;
  });
  return Object.assign({}, collection, {
    items: items
  });
} //Helps handle errors with async await pattern

export var awaitHelper = function awaitHelper(promise) {
  return promise.then(function (data) {
    return {
      data: data,
      error: null
    };
  })["catch"](function (error) {
    return {
      error: error,
      data: null
    };
  });
};
export var getQliticsSchema = function getQliticsSchema() {
  var story = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var card = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Array.from(_arguments).forEach(function (ele) {
    Object.keys(ele).length < 1 && console.warn("Required attribute missing for qlitics --> ".concat(ele));
  }); //Display warning to make debugging easier

  return {
    'story-content-id': story['story-content-id'],
    'story-version-id': story['story-version-id'],
    'card-content-id': card['content-id'],
    'card-version-id': card['content-version-id'],
    'story-element-id': element.id,
    'story-element-type': element.subtype || element.type
  };
};
export var computeAccess = function computeAccess(previousState, currentState) {
  var currentAccess = get(currentState, ["access"], {});
  var currentStoryId = get(Object.keys(currentAccess), [0], "");

  if (currentStoryId in previousState) {
    var storyAccess = previousState[currentStoryId];

    if (storyAccess.granted !== currentAccess[currentStoryId].granted || storyAccess.grantReason !== currentAccess[currentStoryId].grantReason) {
      return _objectSpread({}, previousState, currentAccess);
    }

    return previousState;
  }

  return _objectSpread({}, previousState, currentAccess);
};