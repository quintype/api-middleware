import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import React from "react"; // An item in the infinite scroll

var ScrollItem =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ScrollItem, _React$Component);

  function ScrollItem(props) {
    var _this;

    _classCallCheck(this, ScrollItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollItem).call(this, props));
    _this.state = {
      minHeight: props.minHeight
    };
    return _this;
  }

  _createClass(ScrollItem, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      return React.createElement("div", {
        ref: function ref(node) {
          return _this2.node = node;
        },
        "data-infinite-scroll": this.props.index,
        style: {
          minHeight: this.state.minHeight
        }
      }, this.props.show && this.props.render(Object.assign({
        index: this.props.index
      }, this.props.data)));
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.show && !this.props.show) {
        this.setState({
          minHeight: this.props.minHeight
        });
      } else if (!nextProps.show && this.props.show) {
        this.setState({
          minHeight: this.node.clientHeight
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this3 = this;

      this.props.observers.forEach(function (observer) {
        return observer && observer.observe(_this3.node);
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this4 = this;

      this.props.observers.forEach(function (observer) {
        return observer && observer.unobserve(_this4.node);
      });
    }
  }]);

  return ScrollItem;
}(React.Component); // When this becomes visible, we call loadMore()


var ScrollLoadMore =
/*#__PURE__*/
function (_React$Component2) {
  _inherits(ScrollLoadMore, _React$Component2);

  function ScrollLoadMore() {
    _classCallCheck(this, ScrollLoadMore);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScrollLoadMore).apply(this, arguments));
  }

  _createClass(ScrollLoadMore, [{
    key: "render",
    value: function render() {
      var _this5 = this;

      return React.createElement("div", {
        ref: function ref(node) {
          return _this5.node = node;
        },
        "data-infinite-scroll": "load-more"
      });
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this6 = this;

      this.props.observers.forEach(function (observer) {
        return observer && observer.observe(_this6.node);
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this7 = this;

      this.props.observers.forEach(function (observer) {
        return observer && observer.unobserve(_this7.node);
      });
    }
  }]);

  return ScrollLoadMore;
}(React.Component); // Basic Infinite Scroll, toggles showing items


var InfiniteScrollBase =
/*#__PURE__*/
function (_React$Component3) {
  _inherits(InfiniteScrollBase, _React$Component3);

  function InfiniteScrollBase(props) {
    var _this8;

    _classCallCheck(this, InfiniteScrollBase);

    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(InfiniteScrollBase).call(this, props));
    var initiallyShow = props.initiallyShow || 1;
    _this8.state = {
      visibleComponents: _toConsumableArray(Array(initiallyShow).keys()).reduce(function (arr, i) {
        arr[i] = true;
        return arr;
      }, {})
    };

    if (global.IntersectionObserver) {
      _this8.loadObserver = new IntersectionObserver(function (x) {
        return _this8.intersectionCallback(x);
      }, {
        rootMargin: props.loadMargin || "200px 0px 500px"
      });
    }

    return _this8;
  }

  _createClass(InfiniteScrollBase, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.loadObserver && this.loadObserver.disconnect();
    }
  }, {
    key: "intersectionCallback",
    value: function intersectionCallback(entries) {
      var _this9 = this;

      var visibleComponents = this.state.visibleComponents;
      entries.forEach(function (entry) {
        // Stupid browsers like UC and Mi don't correctly support the spec
        if (entry.isIntersecting === undefined) {
          if (_this9.props.showAllOnLegacyBrowser) {
            entry.isIntersecting = true;
          } else {
            return;
          }
        }

        var item = entry.target.getAttribute("data-infinite-scroll");

        if (item == 'load-more' && entry.isIntersecting) {
          _this9.props.loadNext();
        } else {
          var showItem = _this9.props.neverHideItem ? visibleComponents[item] || entry.isIntersecting : entry.isIntersecting;
          visibleComponents = Object.assign({}, visibleComponents, _defineProperty({}, item, showItem));
        }
      });
      this.setState({
        visibleComponents: visibleComponents
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this10 = this;

      return React.createElement("div", null, this.props.items.map(function (data, index) {
        return React.createElement(ScrollItem, {
          observers: _this10.props.observers.concat([_this10.loadObserver]),
          key: index,
          index: index,
          show: _this10.state.visibleComponents[index],
          render: _this10.props.render,
          data: data,
          minHeight: _this10.props.minHeight || 50
        });
      }), React.createElement(ScrollLoadMore, {
        observers: [this.loadObserver]
      }));
    }
  }]);

  return InfiniteScrollBase;
}(React.Component); // Calls a callback when an item covers bottom 20% of the screen (to change URL)


function withFocusObserver(Component) {
  return (
    /*#__PURE__*/
    function (_React$Component4) {
      _inherits(WithFocusObserver, _React$Component4);

      function WithFocusObserver(props) {
        var _this11;

        _classCallCheck(this, WithFocusObserver);

        _this11 = _possibleConstructorReturn(this, _getPrototypeOf(WithFocusObserver).call(this, props));

        if (global.IntersectionObserver) {
          _this11.focusObserver = new IntersectionObserver(function (x) {
            return _this11.focusCallback(x);
          }, {
            rootMargin: "-".concat(100 - props.focusCallbackAt, "% 0px -").concat(props.focusCallbackAt, "%")
          });
        }

        return _this11;
      }

      _createClass(WithFocusObserver, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.focusObserver && this.focusObserver.disconnect();
        }
      }, {
        key: "focusCallback",
        value: function focusCallback(entries) {
          var _this12 = this;

          entries.forEach(function (entry) {
            var item = entry.target.getAttribute("data-infinite-scroll");

            if (entry.isIntersecting) {
              _this12.props.onFocus(item);
            }
          });
        }
      }, {
        key: "render",
        value: function render() {
          return React.createElement(Component, Object.assign({}, this.props, {
            observers: (this.props.observers || []).concat([this.focusObserver])
          }));
        }
      }]);

      return WithFocusObserver;
    }(React.Component)
  );
}

export var InfiniteScroll =
/*#__PURE__*/
withFocusObserver(InfiniteScrollBase);