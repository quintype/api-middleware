import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { Component } from 'react';
import { connect, batch } from 'react-redux';
import get from "lodash/get";
import { ACCESS_BEING_LOADED, ACCESS_UPDATED, PAYMENT_OPTIONS_UPDATED, SUBSCRIPTION_GROUP_UPDATED, METER_UPDATED } from "../store/actions";
import PropTypes from "prop-types";
import { awaitHelper } from "../utils";

var AccessTypeBase =
/*#__PURE__*/
function (_Component) {
  _inherits(AccessTypeBase, _Component);

  function AccessTypeBase() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, AccessTypeBase);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AccessTypeBase)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "loadScript", function (callback) {
      var accessTypeKey = get(_this.props, ['accessTypeKey']);
      var isStaging = get(_this.props, ['isStaging']);
      var enableAccesstype = get(_this.props, ['enableAccesstype']);

      if (!enableAccesstype) {
        return false;
      }

      if (accessTypeKey && !global.AccessType && global.document) {
        var accessTypeScript = document.createElement('script');
        var accessTypeHost = "https://www.accesstype.com/frontend/accesstype.js?key=".concat(accessTypeKey);

        if (isStaging) {
          accessTypeHost = "https://staging.accesstype.com/frontend/accesstype.js?key=".concat(accessTypeKey, "&env=sandbox");
        }

        accessTypeScript.setAttribute("src", accessTypeHost);
        accessTypeScript.setAttribute("data-accessType-script", "1");
        accessTypeScript.async = 1;

        accessTypeScript.onload = function () {
          return callback();
        };

        document.body.appendChild(accessTypeScript);
        return true;
      }

      global.AccessType && callback();
      return true;
    });

    _defineProperty(_assertThisInitialized(_this), "setUser",
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee(emailAddress, mobileNumber) {
        var _ref2, error, user;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (global.AccessType) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", {});

              case 2:
                _context.next = 4;
                return awaitHelper(global.AccessType.setUser({
                  'emailAddress': emailAddress,
                  'mobileNumber': mobileNumber
                }));

              case 4:
                _ref2 = _context.sent;
                error = _ref2.error;
                user = _ref2.data;

                if (!error) {
                  _context.next = 10;
                  break;
                }

                console.warn("User context setting failed --> ", error);
                return _context.abrupt("return", error);

              case 10:
                return _context.abrupt("return", user);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(_assertThisInitialized(_this), "getSubscription",
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee2() {
      var accessTypeKey, isStaging, accessTypeHost, _ref4, error, subscriptions;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              accessTypeKey = get(_this.props, ['accessTypeKey']);
              isStaging = get(_this.props, ['isStaging']);
              accessTypeHost = "https://www.accesstype.com/api/v1/subscription_groups.json?key=".concat(accessTypeKey);

              if (isStaging) {
                accessTypeHost = "https://staging.accesstype.com/api/v1/subscription_groups.json?key=".concat(accessTypeKey);
              }

              _context2.t0 = awaitHelper;
              _context2.next = 7;
              return global.fetch(accessTypeHost);

            case 7:
              _context2.t1 = _context2.sent.json();
              _context2.next = 10;
              return (0, _context2.t0)(_context2.t1);

            case 10:
              _ref4 = _context2.sent;
              error = _ref4.error;
              subscriptions = _ref4.data;

              if (!error) {
                _context2.next = 15;
                break;
              }

              return _context2.abrupt("return", {
                error: 'subscriptions fetch failed'
              });

            case 15:
              return _context2.abrupt("return", subscriptions["subscription_groups"] || []);

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));

    _defineProperty(_assertThisInitialized(_this), "getPaymentOptions",
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee3() {
      var _ref6, error, paymentOptions;

      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (global.AccessType) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", []);

            case 2:
              _context3.next = 4;
              return awaitHelper(global.AccessType.getPaymentOptions());

            case 4:
              _ref6 = _context3.sent;
              error = _ref6.error;
              paymentOptions = _ref6.data;

              if (!error) {
                _context3.next = 9;
                break;
              }

              return _context3.abrupt("return", {
                error: 'payment options fetch failed'
              });

            case 9:
              return _context3.abrupt("return", paymentOptions);

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));

    _defineProperty(_assertThisInitialized(_this), "runSequentialCalls",
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee4() {
      var user;
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return _this.setUser(_this.props.email, _this.props.phone);

            case 2:
              user = _context4.sent;

              if (user) {
                try {
                  Promise.all([_this.getSubscription(), _this.getPaymentOptions()]).then(function (_ref8) {
                    var _ref9 = _slicedToArray(_ref8, 2),
                        subscriptionGroups = _ref9[0],
                        paymentOptions = _ref9[1];

                    batch(function () {
                      _this.props.subscriptionGroupLoaded(subscriptionGroups);

                      _this.props.paymentOptionsLoaded(paymentOptions);
                    });
                  });
                } catch (e) {
                  console.log("Subscription / payments failed", e);
                }
              }

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));

    _defineProperty(_assertThisInitialized(_this), "getSubscriptionForUser",
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee5() {
      var _ref11, error, _ref11$data, subscriptions;

      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (global.AccessType) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt("return", {});

            case 2:
              _context5.next = 4;
              return awaitHelper(global.AccessType.getSubscriptions());

            case 4:
              _ref11 = _context5.sent;
              error = _ref11.error;
              _ref11$data = _ref11.data;
              subscriptions = _ref11$data === void 0 ? [] : _ref11$data;

              if (!error) {
                _context5.next = 10;
                break;
              }

              return _context5.abrupt("return", error);

            case 10:
              return _context5.abrupt("return", subscriptions);

            case 11:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));

    _defineProperty(_assertThisInitialized(_this), "initAccessType", function () {
      try {
        _this.loadScript(function () {
          return _this.runSequentialCalls();
        });
      } catch (e) {
        console.warn("Accesstype load fail", e);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "initRazorPayPayment", function (selectedPlan) {
      if (!selectedPlan) {
        console.warn('Razor pay needs a plan');
        return false;
      }

      var paymentOptions = _this.props.paymentOptions;
      var id = selectedPlan.id,
          title = selectedPlan.title,
          description = selectedPlan.description,
          priceCents = selectedPlan['price_cents'],
          priceCurrency = selectedPlan['price_currency'],
          durationLength = selectedPlan['duration_length'],
          durationUnit = selectedPlan['duration_unit'];
      var paymentType = get(selectedPlan, ["recurring"]) ? "razorpay_recurring" : "razorpay";
      var paymentObject = {
        type: 'standard',
        plan: {
          id: id,
          title: title,
          description: description,
          price_cents: priceCents,
          price_currency: priceCurrency,
          duration_length: durationLength,
          duration_unit: durationUnit
        },
        payment: {
          payment_type: paymentType,
          amount_cents: priceCents,
          amount_currency: priceCurrency
        }
      };
      return paymentOptions.razorpay.proceed(paymentObject);
    });

    _defineProperty(_assertThisInitialized(_this), "pingBackMeteredStory",
    /*#__PURE__*/
    function () {
      var _ref12 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee6(assetId, accessData) {
        var stringData, meteredBody, _ref13, data, error;

        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                stringData = JSON.stringify(accessData);

                if (!(global.navigator && global.navigator.sendBeacon)) {
                  _context6.next = 4;
                  break;
                }

                global.navigator.sendBeacon("/api/access/v1/stories/".concat(assetId, "/pingback"), stringData);
                return _context6.abrupt("return", true);

              case 4:
                meteredBody = {
                  method: "POST",
                  headers: {
                    "Content-Type": "text/plain"
                  },
                  body: stringData
                };
                _context6.t0 = awaitHelper;
                _context6.next = 8;
                return global.fetch("/api/access/v1/stories/".concat(assetId, "/pingback"), meteredBody);

              case 8:
                _context6.t1 = _context6.sent.json();
                _context6.next = 11;
                return (0, _context6.t0)(_context6.t1);

              case 11:
                _ref13 = _context6.sent;
                data = _ref13.data;
                error = _ref13.error;
                return _context6.abrupt("return", true);

              case 15:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      return function (_x3, _x4) {
        return _ref12.apply(this, arguments);
      };
    }());

    _defineProperty(_assertThisInitialized(_this), "checkAccess",
    /*#__PURE__*/
    function () {
      var _ref14 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee7(assetId) {
        var meteringParam, _ref15, error, accessData, accessById, granted, grantReason, _accessData$data, data;

        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (assetId) {
                  _context7.next = 3;
                  break;
                }

                console.warn('AssetId is required');
                return _context7.abrupt("return", false);

              case 3:
                _this.props.accessIsLoading(true);

                meteringParam = _this.props.disableMetering === true ? '?disable-meter=true' : '';
                _context7.t0 = awaitHelper;
                _context7.next = 8;
                return global.fetch("/api/access/v1/stories/".concat(assetId, "/access").concat(meteringParam));

              case 8:
                _context7.t1 = _context7.sent.json();
                _context7.next = 11;
                return (0, _context7.t0)(_context7.t1);

              case 11:
                _ref15 = _context7.sent;
                error = _ref15.error;
                accessData = _ref15.data;
                accessById = _defineProperty({}, assetId, accessData);

                _this.props.accessUpdated(accessById);

                _this.props.accessIsLoading(false);

                granted = accessData.granted, grantReason = accessData.grantReason, _accessData$data = accessData.data, data = _accessData$data === void 0 ? {} : _accessData$data;

                if (!meteringParam && granted && grantReason === "METERING") {
                  _this.pingBackMeteredStory(assetId, {
                    granted: granted,
                    grantReason: grantReason
                  });

                  _this.props.meterUpdated(data.numberRemaining || -1);
                }

                if (!error) {
                  _context7.next = 21;
                  break;
                }

                return _context7.abrupt("return", error);

              case 21:
                return _context7.abrupt("return", accessById);

              case 22:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      return function (_x5) {
        return _ref14.apply(this, arguments);
      };
    }());

    return _this;
  }

  _createClass(AccessTypeBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.initAccessType();
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;
      return children({
        initAccessType: this.initAccessType,
        initRazorPayPayment: this.initRazorPayPayment,
        checkAccess: this.checkAccess,
        getSubscriptionForUser: this.getSubscriptionForUser,
        accessUpdated: this.props.accessUpdated,
        accessIsLoading: this.props.accessIsLoading
      });
    }
  }]);

  return AccessTypeBase;
}(Component);

var mapStateToProps = function mapStateToProps(state) {
  return {
    subscriptions: state.subscriptions || null,
    paymentOptions: state.paymentOptions || null
  };
};

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
  return {
    subscriptionGroupLoaded: function subscriptionGroupLoaded(subscriptions) {
      return dispatch({
        type: SUBSCRIPTION_GROUP_UPDATED,
        subscriptions: subscriptions
      });
    },
    paymentOptionsLoaded: function paymentOptionsLoaded(paymentOptions) {
      return dispatch({
        type: PAYMENT_OPTIONS_UPDATED,
        paymentOptions: paymentOptions
      });
    },
    accessIsLoading: function accessIsLoading(loading) {
      return dispatch({
        type: ACCESS_BEING_LOADED,
        loading: loading
      });
    },
    accessUpdated: function accessUpdated(access) {
      return dispatch({
        type: ACCESS_UPDATED,
        access: access
      });
    },
    meterUpdated: function meterUpdated(meterCount) {
      return dispatch({
        type: METER_UPDATED,
        meterCount: meterCount
      });
    }
  };
};

export var AccessType =
/*#__PURE__*/
connect(mapStateToProps, mapDispatchToProps)(AccessTypeBase);